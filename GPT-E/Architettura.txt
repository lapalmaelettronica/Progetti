==============================================================
ü§ñ ARCHITETTURA ROBOT INTELLIGENTE IBRIDO
Raspberry Pi + ESP32
==============================================================

üìå OBIETTIVO
Sistema robotico con ChatGPT, voce naturale, memoria estesa e controllo fisico.
Il Raspberry √® il "cervello", l'ESP32 √® la "testa" (voce e sensi locali).

--------------------------------------------------------------
üß† RASPBERRY PI (CERVELLO LOGICO)
--------------------------------------------------------------
RUOLO:
 - Gestisce la conversazione con OpenAI / ChatGPT.
 - Interpreta gli ordini vocali o testuali.
 - Decide le azioni da compiere.
 - Comanda l‚ÄôESP32 per far parlare e muovere la testa.
 - Controlla direttamente i servo/motori del corpo.
 - Salva memoria, log, immagini e preferenze su USB.

COMPITI PRINCIPALI:
 - Input: microfono, tastiera o sensori.
 - Elaborazione: analisi testo e chiamata API OpenAI.
 - Output: invio comandi a ESP32 (voce / LED / espressioni).
 - Controllo servo via GPIO o PCA9685.
 - Memoria in JSON o SQLite su chiavetta USB.

ESEMPIO COMUNICAZIONE CON OPENAI (Python):
------------------------------------------
openai.ChatCompletion.create(
   model="gpt-3.5-turbo",
   messages=[{"role": "user", "content": "Ciao"}]
)

ESEMPIO INVIO COMANDO A ESP32:
------------------------------
ser.write(b"TALK:Ciao, come stai?\n")
ser.write(b"LED:SMILE\n")
ser.write(b"SERVO_EYE:45\n")

--------------------------------------------------------------
üó£Ô∏è ESP32 (TESTA / VOCE / SENSORI LOCALI)
--------------------------------------------------------------
RUOLO:
 - Riceve comandi dal Raspberry.
 - Esegue il Text-to-Speech e parla tramite speaker.
 - Gestisce LED, servo piccoli (occhi, bocca, mimica).
 - Pu√≤ inviare indietro conferme (‚ÄúOK‚Äù, ‚Äúparlato finito‚Äù).

FUNZIONI BASE:
 - TALK:<testo>   ‚Üí pronuncia il testo (Google TTS).
 - LED:<azione>   ‚Üí accende o spegne espressioni luminose.
 - SERVO_EYE:<angolo> ‚Üí muove servo dell‚Äôocchio o testa.

PSEUDOCODICE BASE:
------------------
if (Serial.available()) {
   String cmd = Serial.readStringUntil('\n');
   if (cmd.startsWith("TALK:")) playLongText(cmd.substring(5));
   else if (cmd.startsWith("LED:")) gestisciLED(cmd.substring(4));
   else if (cmd.startsWith("SERVO_EYE:")) muoviServo(cmd.substring(10).toInt());
}

--------------------------------------------------------------
üß© COMUNICAZIONE RASPBERRY ‚Üî ESP32
--------------------------------------------------------------
Tipi di collegamento possibili:
1. üîå Seriale USB  ‚Üí consigliato per iniziare (stabile, semplice)
2. üåê Wi-Fi MQTT   ‚Üí per pi√π moduli (testa, braccia, sensori)
3. üîä WebSocket    ‚Üí per comunicazione in tempo reale (avanzato)

Protocollo base (testuale):
---------------------------
TALK:<stringa di testo>
LED:<azione>
SERVO_<parte>:<valore>
ACK:<messaggio di risposta>

--------------------------------------------------------------
üíæ MEMORIA ESTESA (SU RASPBERRY)
--------------------------------------------------------------
Struttura consigliata su USB:
-----------------------------
/memoria/
 ‚îú‚îÄ‚îÄ conversazioni.json   ‚Üí log chat
 ‚îú‚îÄ‚îÄ persone/             ‚Üí volti riconosciuti
 ‚îú‚îÄ‚îÄ immagini/            ‚Üí contesto visivo
 ‚îú‚îÄ‚îÄ preferenze.json      ‚Üí dati personali
 ‚îî‚îÄ‚îÄ log/                 ‚Üí attivit√† varie

Esempio JSON memoria:
---------------------
{
  "ultimo_saluto": "Ciao Luca!",
  "umore": "felice",
  "azioni_recenti": ["parlato", "girato_testa"],
  "persone_note": ["Luca", "Anna"]
}

--------------------------------------------------------------
üí° COMPONENTI HARDWARE
--------------------------------------------------------------
üß† Raspberry Pi (cervello)
  - OS: Raspberry Pi OS Lite
  - Librerie: Python, openai, gpiozero, pyaudio, opencv (facoltativo)
  - Memoria USB per salvataggi
  - Scheda servo PCA9685 (opzionale)

üó£Ô∏è ESP32 (testa/voce)
  - Collegato via USB o Wi-Fi al Raspberry
  - Speaker I2S (DOUT=25, BCLK=33, LRC=32)
  - Micro servo o LED RGB per espressioni

--------------------------------------------------------------
üéÆ CICLO LOGICO DI FUNZIONAMENTO
--------------------------------------------------------------
1Ô∏è‚É£ Ascolta / riceve un comando vocale o testuale.
2Ô∏è‚É£ Invia la frase a ChatGPT.
3Ô∏è‚É£ Riceve la risposta testuale.
4Ô∏è‚É£ Salva nel file di memoria (cronologia).
5Ô∏è‚É£ Estrae la parte da pronunciare ‚Üí manda a ESP32.
6Ô∏è‚É£ Analizza eventuali istruzioni ‚Üí muove servo sul Raspberry.
7Ô∏è‚É£ Attende risposta dall‚ÄôESP32 (fine parlato).
8Ô∏è‚É£ Pronto per nuovo comando.

--------------------------------------------------------------
üîã VANTAGGI DELL‚ÄôARCHITETTURA IBRIDA
--------------------------------------------------------------
‚úÖ Audio fluido e indipendente.
‚úÖ Raspberry libero per calcolo e IA.
‚úÖ Modulare (puoi aggiungere altre schede ESP32 per braccia, sensori).
‚úÖ Espandibile: visione artificiale, riconoscimento facciale, memoria estesa.
‚úÖ Sicura: ogni modulo ha compiti specifici.

--------------------------------------------------------------
üîÆ ESTENSIONI FUTURE
--------------------------------------------------------------
- Speech-to-Text (microfono + Whisper / Google STT).
- Visione (OpenCV / riconoscimento volti).
- Memoria semantica (embeddings vettoriali).
- MQTT per pi√π ESP (testa, braccia, gambe).
- Addestramento ‚Äúpersonalit√†‚Äù con cronologia locale.

==============================================================
üßæ NOTE FINALI
--------------------------------------------------------------
‚Ä¢ Raspberry = cervello / logica / memoria
‚Ä¢ ESP32     = voce / espressioni / sensoristica rapida
‚Ä¢ Comunicazione testuale semplice: TALK, LED, SERVO
‚Ä¢ Salvataggio ricordi e log su USB
‚Ä¢ Scalabile, stabile, ‚Äúumanoide‚Äù nel comportamento
==============================================================
